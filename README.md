## Общая информация
Задание выполнено в 3D, с использованием Unity NavMesh. Версия редактора Unity: 2022.3.16f1. Сборка доступна на Github Release.

## Что реализовано
Игровое поле с препятствиями, основная логика дрона с его полным циклом поведения с использованием NavMesh, случайное появление ресурсов, ui для управления симуляцией, но реализовано не все, что было указано. Дроны находят свободный ресурс, выстраивают путь, собирают ресурс и относят к себе на базу, а после повторяют данный процесс. Случайное появление ресурсов реализовано через вычисление случайной точки на поле и проверки ее на наличие препятствий, а не через предопределенные spawnpoint'ы. Также была внедрена самописная система пуллинга игровых объектов.

## Описание архитектуры
Есть компонент Drone, он хранит в себе состояние и решает на его основе, что ему делать. Для поиска ближайших ресурсов он использует ResourceFinder компонент, который запускает корутину и вызывает callback, когда находит ресурс.
В основном Drone управляет именно NavMesh Agent, а также хранит определяет ресурс, который он зарезеривовал для себя. В теории его можно декомпозировать больше, а также использовать State-паттерн в виде объектов, а не switch + enum.
Для партикла был сделан компонент DroneParticleEmitter. Предполагается, что он подписывается на события других компонентов дрона и вызывает свои методы для воспроизведения партиклов.

За появление ресурсов отвечает класс ResourceSpawner. Помимо контроля над жизненным циклом, он еще и вычисляет свободное место на арене (без препятствия) и создает ресурс там.

Для контроля численности дронов существует два класса: DronePopulationRegulator и DroneSpawner. Первый хранит список дронов каждый фракции и при запросе от пользователя подчищает, либо добавляет новые дроны. Для создания используется DroneSpawner, который создает дронов на базе на случайном spawnpoint'е. Контроль скорости я не реализовал, однако я думаю, можно сделать класс-контейнер для взаимодействия со списками дронов, к которыму могут обращаться различные системы: для чтения или модификации, что позволило бы изменять скорость дронов через условный сервис DroneSpeedRegulator.

## Использованные инструменты и подходы
Как уже было сказано, был использован NavMesh, самописная система пуллинга игровых объектов. Из подходов: компонент-ориентированная архитектура.
